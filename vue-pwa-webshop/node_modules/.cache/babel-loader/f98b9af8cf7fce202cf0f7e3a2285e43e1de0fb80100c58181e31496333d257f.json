{"ast":null,"code":"import { defineStore } from 'pinia';\nimport { ref, computed } from 'vue';\nimport ProductService from '@/services/productService';\nimport { db } from '@/main';\nimport { collection, doc, setDoc, getDoc, getDocs, query, orderBy, limit } from 'firebase/firestore';\nexport const useProductsStore = defineStore('products', () => {\n  const products = ref([]);\n  const categories = ref([]);\n  const loading = ref(false);\n  const error = ref(null);\n  const lastFetch = ref(null);\n  const priceHistory = ref({});\n  const featuredProducts = computed(() => products.value.slice(0, 4));\n  const loadProducts = async (force = false) => {\n    const now = Date.now();\n    if (!force && lastFetch.value && now - lastFetch.value < 5 * 60 * 1000) {\n      return products.value;\n    }\n    try {\n      loading.value = true;\n      error.value = null;\n      const data = await ProductService.getAllProducts();\n      products.value = data;\n      lastFetch.value = now;\n      await storeProductsInFirestore(data);\n      await trackPriceChanges(data);\n      return data;\n    } catch (err) {\n      console.error('Error loading products:', err);\n      error.value = err.message;\n      return [];\n    } finally {\n      loading.value = false;\n    }\n  };\n  const loadCategories = async () => {\n    try {\n      loading.value = true;\n      categories.value = await ProductService.getCategories();\n      return categories.value;\n    } catch (err) {\n      console.error('Error loading categories:', err);\n      error.value = err.message;\n      return [];\n    } finally {\n      loading.value = false;\n    }\n  };\n  const getProductById = async id => {\n    const existing = products.value.find(p => p.id === parseInt(id));\n    if (existing) return existing;\n    try {\n      loading.value = true;\n      const product = await ProductService.getProductById(id);\n      await loadPriceHistory(id);\n      return product;\n    } catch (err) {\n      console.error('Error loading product:', err);\n      error.value = err.message;\n      return null;\n    } finally {\n      loading.value = false;\n    }\n  };\n  const getProductsByCategory = async category => {\n    try {\n      loading.value = true;\n      const data = await ProductService.getProductsByCategory(category);\n      return data;\n    } catch (err) {\n      console.error('Error loading category products:', err);\n      error.value = err.message;\n      return [];\n    } finally {\n      loading.value = false;\n    }\n  };\n  const searchProducts = query => {\n    const searchTerm = query.toLowerCase();\n    return products.value.filter(product => product.title.toLowerCase().includes(searchTerm) || product.description.toLowerCase().includes(searchTerm) || product.category.toLowerCase().includes(searchTerm));\n  };\n  const storeProductsInFirestore = async productsData => {\n    try {\n      const batch = [];\n      const timestamp = new Date().toISOString();\n      for (const product of productsData) {\n        batch.push(setDoc(doc(db, 'products', product.id.toString()), {\n          ...product,\n          lastUpdated: timestamp\n        }, {\n          merge: true\n        }));\n      }\n      await Promise.all(batch);\n    } catch (err) {\n      console.error('Error storing products in Firestore:', err);\n    }\n  };\n  const trackPriceChanges = async productsData => {\n    try {\n      const timestamp = new Date().toISOString();\n      for (const product of productsData) {\n        await setDoc(doc(db, 'priceHistory', `${product.id}_${Date.now()}`), {\n          productId: product.id,\n          price: product.price,\n          timestamp\n        });\n        const previousPrice = await getPreviousPrice(product.id);\n        if (previousPrice && product.price < previousPrice) {\n          await checkPriceAlerts(product.id, previousPrice, product.price);\n        }\n      }\n    } catch (err) {\n      console.error('Error tracking price changes:', err);\n    }\n  };\n  const getPreviousPrice = async productId => {\n    try {\n      const q = query(collection(db, 'priceHistory'), orderBy('timestamp', 'desc'), limit(2));\n      const snapshot = await getDocs(q);\n      const prices = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        if (data.productId === productId) {\n          prices.push(data.price);\n        }\n      });\n      return prices[1] || null;\n    } catch (err) {\n      console.error('Error getting previous price:', err);\n      return null;\n    }\n  };\n  const loadPriceHistory = async productId => {\n    try {\n      const q = query(collection(db, 'priceHistory'), orderBy('timestamp', 'desc'), limit(30));\n      const snapshot = await getDocs(q);\n      const history = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        if (data.productId === parseInt(productId)) {\n          history.push({\n            price: data.price,\n            date: data.timestamp\n          });\n        }\n      });\n      priceHistory.value[productId] = history;\n      return history;\n    } catch (err) {\n      console.error('Error loading price history:', err);\n      return [];\n    }\n  };\n  const checkPriceAlerts = async (productId, oldPrice, newPrice) => {\n    const product = products.value.find(p => p.id === productId);\n    if (product) {\n      const percentage = Math.round((oldPrice - newPrice) / oldPrice * 100);\n      console.log(`Price drop alert: ${product.title} dropped by ${percentage}%`);\n    }\n  };\n  return {\n    products,\n    categories,\n    loading,\n    error,\n    priceHistory,\n    featuredProducts,\n    loadProducts,\n    loadCategories,\n    getProductById,\n    getProductsByCategory,\n    searchProducts,\n    loadPriceHistory\n  };\n});","map":{"version":3,"names":["defineStore","ref","computed","ProductService","db","collection","doc","setDoc","getDoc","getDocs","query","orderBy","limit","useProductsStore","products","categories","loading","error","lastFetch","priceHistory","featuredProducts","value","slice","loadProducts","force","now","Date","data","getAllProducts","storeProductsInFirestore","trackPriceChanges","err","console","message","loadCategories","getCategories","getProductById","id","existing","find","p","parseInt","product","loadPriceHistory","getProductsByCategory","category","searchProducts","searchTerm","toLowerCase","filter","title","includes","description","productsData","batch","timestamp","toISOString","push","toString","lastUpdated","merge","Promise","all","productId","price","previousPrice","getPreviousPrice","checkPriceAlerts","q","snapshot","prices","forEach","history","date","oldPrice","newPrice","percentage","Math","round","log"],"sources":["C:/Users/veszi/Desktop/Portofolio/vue-pwa-webshop/src/store/products.js"],"sourcesContent":["import { defineStore } from 'pinia'\r\nimport { ref, computed } from 'vue'\r\nimport ProductService from '@/services/productService'\r\nimport { db } from '@/main'\r\nimport { collection, doc, setDoc, getDoc, getDocs, query, orderBy, limit } from 'firebase/firestore'\r\n\r\nexport const useProductsStore = defineStore('products', () => {\r\n  const products = ref([])\r\n  const categories = ref([])\r\n  const loading = ref(false)\r\n  const error = ref(null)\r\n  const lastFetch = ref(null)\r\n  const priceHistory = ref({})\r\n\r\n  const featuredProducts = computed(() => \r\n    products.value.slice(0, 4)\r\n  )\r\n\r\n  const loadProducts = async (force = false) => {\r\n    const now = Date.now()\r\n    if (!force && lastFetch.value && (now - lastFetch.value) < 5 * 60 * 1000) {\r\n      return products.value\r\n    }\r\n\r\n    try {\r\n      loading.value = true\r\n      error.value = null\r\n      \r\n      const data = await ProductService.getAllProducts()\r\n      products.value = data\r\n      lastFetch.value = now\r\n      \r\n      await storeProductsInFirestore(data)\r\n      \r\n      await trackPriceChanges(data)\r\n      \r\n      return data\r\n    } catch (err) {\r\n      console.error('Error loading products:', err)\r\n      error.value = err.message\r\n      return []\r\n    } finally {\r\n      loading.value = false\r\n    }\r\n  }\r\n\r\n  const loadCategories = async () => {\r\n    try {\r\n      loading.value = true\r\n      categories.value = await ProductService.getCategories()\r\n      return categories.value\r\n    } catch (err) {\r\n      console.error('Error loading categories:', err)\r\n      error.value = err.message\r\n      return []\r\n    } finally {\r\n      loading.value = false\r\n    }\r\n  }\r\n\r\n  const getProductById = async (id) => {\r\n    const existing = products.value.find(p => p.id === parseInt(id))\r\n    if (existing) return existing\r\n\r\n    try {\r\n      loading.value = true\r\n      const product = await ProductService.getProductById(id)\r\n      \r\n      await loadPriceHistory(id)\r\n      \r\n      return product\r\n    } catch (err) {\r\n      console.error('Error loading product:', err)\r\n      error.value = err.message\r\n      return null\r\n    } finally {\r\n      loading.value = false\r\n    }\r\n  }\r\n\r\n  const getProductsByCategory = async (category) => {\r\n    try {\r\n      loading.value = true\r\n      const data = await ProductService.getProductsByCategory(category)\r\n      return data\r\n    } catch (err) {\r\n      console.error('Error loading category products:', err)\r\n      error.value = err.message\r\n      return []\r\n    } finally {\r\n      loading.value = false\r\n    }\r\n  }\r\n\r\n  const searchProducts = (query) => {\r\n    const searchTerm = query.toLowerCase()\r\n    return products.value.filter(product => \r\n      product.title.toLowerCase().includes(searchTerm) ||\r\n      product.description.toLowerCase().includes(searchTerm) ||\r\n      product.category.toLowerCase().includes(searchTerm)\r\n    )\r\n  }\r\n\r\n  const storeProductsInFirestore = async (productsData) => {\r\n    try {\r\n      const batch = []\r\n      const timestamp = new Date().toISOString()\r\n      \r\n      for (const product of productsData) {\r\n        batch.push(\r\n          setDoc(doc(db, 'products', product.id.toString()), {\r\n            ...product,\r\n            lastUpdated: timestamp\r\n          }, { merge: true })\r\n        )\r\n      }\r\n      \r\n      await Promise.all(batch)\r\n    } catch (err) {\r\n      console.error('Error storing products in Firestore:', err)\r\n    }\r\n  }\r\n\r\n  const trackPriceChanges = async (productsData) => {\r\n    try {\r\n      const timestamp = new Date().toISOString()\r\n      \r\n      for (const product of productsData) {\r\n        await setDoc(\r\n          doc(db, 'priceHistory', `${product.id}_${Date.now()}`),\r\n          {\r\n            productId: product.id,\r\n            price: product.price,\r\n            timestamp\r\n          }\r\n        )\r\n        \r\n        const previousPrice = await getPreviousPrice(product.id)\r\n        if (previousPrice && product.price < previousPrice) {\r\n          await checkPriceAlerts(product.id, previousPrice, product.price)\r\n        }\r\n      }\r\n    } catch (err) {\r\n      console.error('Error tracking price changes:', err)\r\n    }\r\n  }\r\n\r\n  const getPreviousPrice = async (productId) => {\r\n    try {\r\n      const q = query(\r\n        collection(db, 'priceHistory'),\r\n        orderBy('timestamp', 'desc'),\r\n        limit(2)\r\n      )\r\n      \r\n      const snapshot = await getDocs(q)\r\n      const prices = []\r\n      \r\n      snapshot.forEach(doc => {\r\n        const data = doc.data()\r\n        if (data.productId === productId) {\r\n          prices.push(data.price)\r\n        }\r\n      })\r\n      \r\n      return prices[1] || null \r\n    } catch (err) {\r\n      console.error('Error getting previous price:', err)\r\n      return null\r\n    }\r\n  }\r\n\r\n  const loadPriceHistory = async (productId) => {\r\n    try {\r\n      const q = query(\r\n        collection(db, 'priceHistory'),\r\n        orderBy('timestamp', 'desc'),\r\n        limit(30)\r\n      )\r\n      \r\n      const snapshot = await getDocs(q)\r\n      const history = []\r\n      \r\n      snapshot.forEach(doc => {\r\n        const data = doc.data()\r\n        if (data.productId === parseInt(productId)) {\r\n          history.push({\r\n            price: data.price,\r\n            date: data.timestamp\r\n          })\r\n        }\r\n      })\r\n      \r\n      priceHistory.value[productId] = history\r\n      return history\r\n    } catch (err) {\r\n      console.error('Error loading price history:', err)\r\n      return []\r\n    }\r\n  }\r\n\r\n  const checkPriceAlerts = async (productId, oldPrice, newPrice) => {\r\n    const product = products.value.find(p => p.id === productId)\r\n    if (product) {\r\n      const percentage = Math.round(((oldPrice - newPrice) / oldPrice) * 100)\r\n      \r\n      console.log(`Price drop alert: ${product.title} dropped by ${percentage}%`)\r\n    }\r\n  }\r\n\r\n  return {\r\n    products,\r\n    categories,\r\n    loading,\r\n    error,\r\n    priceHistory,\r\n    featuredProducts,\r\n    loadProducts,\r\n    loadCategories,\r\n    getProductById,\r\n    getProductsByCategory,\r\n    searchProducts,\r\n    loadPriceHistory\r\n  }\r\n})\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}